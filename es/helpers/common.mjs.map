{"version":3,"file":"common.mjs","sources":["../../src/helpers/common.ts"],"sourcesContent":["import type { InjectionKey } from 'vue'\r\nimport type { EventEmitter } from '@vexip-ui/utils'\r\nimport type { Layout, LayoutInstance, LayoutItem } from './types'\r\n\r\nexport const LAYOUT_KEY = Symbol('LAYOUT_KEY') as InjectionKey<LayoutInstance>\r\nexport const EMITTER_KEY = Symbol('EMITTER_KEY') as InjectionKey<EventEmitter>\r\n\r\n/**\r\n * 返回布局的底部坐标。\r\n *\r\n * @param layout 布局数组。\r\n * @return 底部坐标。\r\n */\r\nexport function bottom(layout: Layout): number {\r\n  let max = 0\r\n  let bottomY\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    bottomY = layout[i].y + layout[i].h\r\n    if (bottomY > max) max = bottomY\r\n  }\r\n  return max\r\n}\r\n\r\nexport function cloneLayout(layout: Layout): Layout {\r\n  const newLayout = Array(layout.length)\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    newLayout[i] = cloneLayoutItem(layout[i])\r\n  }\r\n  return newLayout\r\n}\r\n\r\n// 快速路径到克隆，因为这是单态的\r\nexport function cloneLayoutItem(layoutItem: LayoutItem): LayoutItem {\r\n  // return JSON.parse(JSON.stringify(layoutItem))\r\n  return { ...layoutItem }\r\n}\r\n\r\n/**\r\n * 给定两个布局项，检查它们是否碰撞。\r\n *\r\n * @return 如果碰撞则返回true。\r\n */\r\nexport function collides(l1: LayoutItem, l2: LayoutItem): boolean {\r\n  if (l1 === l2) return false // 相同元素\r\n  if (l1.x + l1.w <= l2.x) return false // l1在l2左侧\r\n  if (l1.x >= l2.x + l2.w) return false // l1在l2右侧\r\n  if (l1.y + l1.h <= l2.y) return false // l1在l2上方\r\n  if (l1.y >= l2.y + l2.h) return false // l1在l2下方\r\n  return true // 盒子重叠\r\n}\r\n\r\n/**\r\n * 给定一个布局，对其进行压缩。即遍历每个 y 坐标并移除项目之间的空隙。\r\n *\r\n * @param  layout 布局。\r\n * @param  verticalCompact 是否垂直压缩布局。\r\n * @param  minPositions 最小位置映射。\r\n * @return 压缩后的布局。\r\n */\r\nexport function compact(layout: Layout, verticalCompact?: boolean, minPositions?: any): Layout {\r\n  // 静态项立即放入 compareWith 数组，这样其它项会围绕它们排布。\r\n  const compareWith = getStatics(layout)\r\n  // 按行列遍历所有项。\r\n  const sorted = sortLayoutItemsByRowCol(layout)\r\n  // 存储新项。\r\n  const out: Layout = Array(layout.length)\r\n\r\n  for (let i = 0, len = sorted.length; i < len; i++) {\r\n    let l = sorted[i]\r\n\r\n    // 不移动 static 元素\r\n    if (!l.static) {\r\n      l = compactItem(compareWith, l, verticalCompact, minPositions)\r\n\r\n      // 添加到比较数组，我们只与它之前的元素做碰撞检测。\r\n      // 静态项已经在该数组中。\r\n      compareWith.push(l)\r\n    }\r\n\r\n    // 添加到输出数组以保证顺序正确。\r\n    out[layout.findIndex(i => i.i === l.i)] = l\r\n\r\n    // 清除 moved 标记。\r\n    l.moved = false\r\n  }\r\n\r\n  return out\r\n}\r\n\r\n/**\r\n * 压缩布局中的单个项。\r\n */\r\nexport function compactItem(\r\n  compareWith: Layout,\r\n  l: LayoutItem,\r\n  verticalCompact?: boolean,\r\n  minPositions?: any,\r\n): LayoutItem {\r\n  if (verticalCompact) {\r\n    // 在不碰撞的情况下尽可能向上移动元素。\r\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\r\n      l.y--\r\n    }\r\n  } else if (minPositions) {\r\n    const minY = minPositions[l.i].y\r\n    while (l.y > minY && !getFirstCollision(compareWith, l)) {\r\n      l.y--\r\n    }\r\n  }\r\n\r\n  // 向下移动，并持续向下直到不再碰撞。\r\n  let collides\r\n  while ((collides = getFirstCollision(compareWith, l))) {\r\n    l.y = collides.y + collides.h\r\n  }\r\n  return l\r\n}\r\n\r\n/**\r\n * 给定一个布局，确保所有元素都在其边界内。\r\n *\r\n * @param  layout 布局数组。\r\n * @param  bounds 列数边界。\r\n */\r\nexport function correctBounds(layout: Layout, bounds: { cols: number }): Layout {\r\n  const collidesWith = getStatics(layout)\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    const l = layout[i]\r\n    // 右侧越界\r\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w\r\n    // 左侧越界\r\n    if (l.x < 0) {\r\n      l.x = 0\r\n      l.w = bounds.cols\r\n    }\r\n    if (!l.static) collidesWith.push(l)\r\n    else {\r\n      // 如果是 static 且与其它 static 碰撞，则向下移动。\r\n      // 不能简单重叠，需要更优处理。\r\n      while (getFirstCollision(collidesWith, l)) {\r\n        l.y++\r\n      }\r\n    }\r\n  }\r\n  return layout\r\n}\r\n\r\n/**\r\n * 通过 ID 获取布局项，便于后续覆盖。\r\n *\r\n * @param    layout 布局数组。\r\n * @param   id     标识\r\n * @return     该 ID 对应的项。\r\n */\r\nexport function getLayoutItem(layout: Layout, id: number | string): LayoutItem | undefined {\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    if (layout[i].i === id) return layout[i]\r\n  }\r\n}\r\n\r\n/**\r\n * 返回与给定项发生碰撞的第一个项。\r\n * 遍历顺序似乎无关紧要（也许并不理想）。\r\n *\r\n * @param  layoutItem 布局项。\r\n * @return 发生碰撞的项，或 undefined。\r\n */\r\nexport function getFirstCollision(layout: Layout, layoutItem: LayoutItem): LayoutItem | undefined {\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    if (collides(layout[i], layoutItem)) return layout[i]\r\n  }\r\n}\r\n\r\nexport function getAllCollisions(layout: Layout, layoutItem: LayoutItem): Array<LayoutItem> {\r\n  return layout.filter(l => collides(l, layoutItem))\r\n}\r\n\r\n/**\r\n * 获取所有 static 元素。\r\n * @param layout 布局对象数组。\r\n * @return  static 布局项数组。\r\n */\r\nexport function getStatics(layout: Layout): Array<LayoutItem> {\r\n  return layout.filter(l => l.static)\r\n}\r\n\r\n/**\r\n * 移动一个元素，并负责级联移动其它元素。\r\n *\r\n * @param layout 完整布局。\r\n * @param layoutItem 要移动的元素。\r\n * @param x 网格单位的 X。\r\n * @param y 网格单位的 Y。\r\n * @param isUserAction 是否用户拖拽/调整导致。\r\n */\r\nexport function moveElement(\r\n  layout: Layout,\r\n  layoutItem: LayoutItem,\r\n  x?: number,\r\n  y?: number,\r\n  isUserAction = false,\r\n  preventCollision = false,\r\n): Layout {\r\n  if (layoutItem.static) return layout\r\n\r\n  const oldX = layoutItem.x\r\n  const oldY = layoutItem.y\r\n\r\n  const movingUp = y && layoutItem.y > y\r\n  // 这比扩展对象要快很多\r\n  if (typeof x === 'number') layoutItem.x = x\r\n  if (typeof y === 'number') layoutItem.y = y\r\n  layoutItem.moved = true\r\n\r\n  // 如果发生碰撞，则移动。\r\n  // 在进行比较时，我们必须对要比较的项进行排序\r\n  // 以确保在发生多重碰撞时，我们获得的是\r\n  // 最近的碰撞。\r\n  let sorted = sortLayoutItemsByRowCol(layout)\r\n  if (movingUp) sorted = sorted.reverse()\r\n  const collisions = getAllCollisions(sorted, layoutItem)\r\n\r\n  if (preventCollision && collisions.length) {\r\n    layoutItem.x = oldX\r\n    layoutItem.y = oldY\r\n    layoutItem.moved = false\r\n    return layout\r\n  }\r\n\r\n  // 移动每个发生碰撞的项。\r\n  for (let i = 0, len = collisions.length; i < len; i++) {\r\n    const collision = collisions[i]\r\n\r\n    // 短路处理，避免无限循环\r\n    if (collision.moved) continue\r\n\r\n    // 这样在向上移动时会更精确一些，因为会稍等再交换。\r\n    if (layoutItem.y > collision.y && layoutItem.y - collision.y > collision.h / 4) continue\r\n\r\n    // 不移动静态项 - 我们必须将 *这个* 元素移开\r\n    if (collision.static) {\r\n      layout = moveElementAwayFromCollision(layout, collision, layoutItem, isUserAction)\r\n    } else {\r\n      layout = moveElementAwayFromCollision(layout, layoutItem, collision, isUserAction)\r\n    }\r\n  }\r\n\r\n  return layout\r\n}\r\n\r\n/**\r\n * 根据碰撞结果将元素移开：有空间则尝试向上，否则向下。\r\n *\r\n * @param layout 完整布局。\r\n * @param collidesWith 与之碰撞的项。\r\n * @param itemToMove 需要移动的项。\r\n * @param isUserAction 是否由用户操作触发。\r\n */\r\nexport function moveElementAwayFromCollision(\r\n  layout: Layout,\r\n  collidesWith: LayoutItem,\r\n  itemToMove: LayoutItem,\r\n  isUserAction?: boolean,\r\n): Layout {\r\n  const preventCollision = false // we're already colliding\r\n  // 如果碰撞上方有足够空间放置该元素，则移动到上方。\r\n  // 我们只对主要碰撞执行此操作，因为在级联中可能会出现问题\r\n  // 导致不必要的交换行为。\r\n  if (isUserAction) {\r\n    // 创建一个虚拟项，以便我们在此不修改项，仅在 moveElement 中修改。\r\n    const fakeItem: LayoutItem = {\r\n      x: itemToMove.x,\r\n      y: itemToMove.y,\r\n      w: itemToMove.w,\r\n      h: itemToMove.h,\r\n      i: '-1',\r\n    }\r\n    fakeItem.y = Math.max(collidesWith.y - itemToMove.h, 0)\r\n    if (!getFirstCollision(layout, fakeItem)) {\r\n      return moveElement(layout, itemToMove, undefined, fakeItem.y, preventCollision)\r\n    }\r\n  }\r\n\r\n  // 之前的优化是直接移动到碰撞下方，但这可能会导致问题\r\n  // 级联移动时，某个项可能会跳过碰撞并导致顺序反转。\r\n  return moveElement(layout, itemToMove, undefined, itemToMove.y + 1, preventCollision)\r\n}\r\n\r\n/**\r\n * 将数字转为百分比字符串。\r\n *\r\n * @param   num 任意数字\r\n * @return      百分比字符串。\r\n */\r\nexport function perc(num: number): string {\r\n  return num * 100 + '%'\r\n}\r\n\r\nexport function setTransform(top: number, left: number, width: number, height: number) {\r\n  // 将无单位值替换为 px\r\n  const translate = 'translate3d(' + left + 'px,' + top + 'px, 0)'\r\n  return {\r\n    transform: translate,\r\n    WebkitTransform: translate,\r\n    MozTransform: translate,\r\n    msTransform: translate,\r\n    OTransform: translate,\r\n    width: width + 'px',\r\n    height: height + 'px',\r\n    position: 'absolute',\r\n  }\r\n}\r\n/**\r\n * 与 setTransform 类似，但返回基于 right 的负值位移。\r\n */\r\nexport function setTransformRtl(top: number, right: number, width: number, height: number) {\r\n  // 将无单位值替换为 px\r\n  const translate = 'translate3d(' + right * -1 + 'px,' + top + 'px, 0)'\r\n  return {\r\n    transform: translate,\r\n    WebkitTransform: translate,\r\n    MozTransform: translate,\r\n    msTransform: translate,\r\n    OTransform: translate,\r\n    width: width + 'px',\r\n    height: height + 'px',\r\n    position: 'absolute',\r\n  }\r\n}\r\n\r\nexport function setTopLeft(top: number, left: number, width: number, height: number) {\r\n  return {\r\n    top: top + 'px',\r\n    left: left + 'px',\r\n    width: width + 'px',\r\n    height: height + 'px',\r\n    position: 'absolute',\r\n  }\r\n}\r\n/**\r\n * 与 setTopLeft 类似，但使用 right 而不是 left。\r\n */\r\nexport function setTopRight(top: number, right: number, width: number, height: number) {\r\n  return {\r\n    top: top + 'px',\r\n    right: right + 'px',\r\n    width: width + 'px',\r\n    height: height + 'px',\r\n    position: 'absolute',\r\n  }\r\n}\r\n\r\n/**\r\n * 获取按从左到右、从上到下排序的布局项，static 优先。\r\n */\r\nexport function sortLayoutItemsByRowCol(layout: Layout): Layout {\r\n  return Array.from(layout).sort(function (a, b) {\r\n    if (a.y === b.y && a.x === b.x) {\r\n      return 0\r\n    }\r\n\r\n    if (a.y > b.y || (a.y === b.y && a.x > b.x)) {\r\n      return 1\r\n    }\r\n\r\n    return -1\r\n  })\r\n}\r\n\r\n/**\r\n * 校验布局，若不合法则抛出错误。\r\n *\r\n * @param layout 布局项数组。\r\n * @param contextName 错误语境名。\r\n * @throw 验证错误。\r\n */\r\nexport function validateLayout(layout: Layout, contextName?: string): void {\r\n  contextName = contextName || 'Layout'\r\n  const subProps = ['x', 'y', 'w', 'h']\r\n  const keyArr = []\r\n  if (!Array.isArray(layout)) throw new Error(contextName + ' must be an array!')\r\n  for (let i = 0, len = layout.length; i < len; i++) {\r\n    const item = layout[i]\r\n    for (let j = 0; j < subProps.length; j++) {\r\n      if (typeof (item as any)[subProps[j]] !== 'number') {\r\n        throw new Error(\r\n          'VueGridLayout: ' + contextName + '[' + i + '].' + subProps[j] + ' must be a number!',\r\n        )\r\n      }\r\n    }\r\n\r\n    if (item.i === undefined || item.i === null) {\r\n      throw new Error('VueGridLayout: ' + contextName + '[' + i + '].i cannot be null!')\r\n    }\r\n\r\n    if (typeof item.i !== 'number' && typeof item.i !== 'string') {\r\n      throw new Error('VueGridLayout: ' + contextName + '[' + i + '].i must be a string or number!')\r\n    }\r\n\r\n    if (keyArr.indexOf(item.i) >= 0) {\r\n      throw new Error('VueGridLayout: ' + contextName + '[' + i + '].i must be unique!')\r\n    }\r\n    keyArr.push(item.i)\r\n\r\n    if (item.static !== undefined && typeof item.static !== 'boolean') {\r\n      throw new Error('VueGridLayout: ' + contextName + '[' + i + '].static must be a boolean!')\r\n    }\r\n  }\r\n}\r\n\r\n// Flow 无法很好推断，这里直接使用 Object\r\nexport function autoBindHandlers(\r\n  el: Record<string, (...args: any[]) => any>,\r\n  fns: Array<string>,\r\n): void {\r\n  fns.forEach(key => (el[key] = el[key].bind(el)))\r\n}\r\n\r\n/**\r\n * 将 JS 对象转换为 CSS 字符串，类似 React 的输出。\r\n */\r\nexport function createMarkup(obj: Record<string, any>) {\r\n  const keys = Object.keys(obj)\r\n  if (!keys.length) return ''\r\n  let i\r\n  const len = keys.length\r\n  let result = ''\r\n\r\n  for (i = 0; i < len; i++) {\r\n    const key = keys[i]\r\n    const val = obj[key]\r\n    result += hyphenate(key) + ':' + addPx(key, val) + ';'\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/* 下列列表来源于 React 核心 */\r\nexport const IS_UNITLESS: Record<string, boolean> = {\r\n  animationIterationCount: true,\r\n  boxFlex: true,\r\n  boxFlexGroup: true,\r\n  boxOrdinalGroup: true,\r\n  columnCount: true,\r\n  flex: true,\r\n  flexGrow: true,\r\n  flexPositive: true,\r\n  flexShrink: true,\r\n  flexNegative: true,\r\n  flexOrder: true,\r\n  gridRow: true,\r\n  gridColumn: true,\r\n  fontWeight: true,\r\n  lineClamp: true,\r\n  lineHeight: true,\r\n  opacity: true,\r\n  order: true,\r\n  orphans: true,\r\n  tabSize: true,\r\n  widows: true,\r\n  zIndex: true,\r\n  zoom: true,\r\n\r\n  // SVG 相关属性\r\n  fillOpacity: true,\r\n  stopOpacity: true,\r\n  strokeDashoffset: true,\r\n  strokeOpacity: true,\r\n  strokeWidth: true,\r\n}\r\n\r\n/**\r\n * 为数值型样式追加 px（除非在无单位白名单内）。\r\n */\r\nexport function addPx(name: string, value: number | string) {\r\n  if (typeof value === 'number' && !IS_UNITLESS[name]) {\r\n    return value + 'px'\r\n  } else {\r\n    return value\r\n  }\r\n}\r\n\r\nexport const hyphenateRE = /([a-z\\d])([A-Z])/g\r\n\r\n/**\r\n * 将 camelCase 字符串连字符化。\r\n */\r\nexport function hyphenate(str: string) {\r\n  return str.replace(hyphenateRE, '$1-$2').toLowerCase()\r\n}\r\n\r\nexport function findItemInArray(array: any[], property: string, value: any) {\r\n  for (let i = 0; i < array.length; i++) {\r\n    if (array[i][property] === value) {\r\n      return true\r\n    }\r\n  }\r\n\r\n  return false\r\n}\r\n\r\nexport function findAndRemove(array: any[], property: string, value: any) {\r\n  array.forEach(function (result, index) {\r\n    if (result[property] === value) {\r\n      // Remove from array\r\n      array.splice(index, 1)\r\n    }\r\n  })\r\n}\r\n\r\nexport function useNameHelper(block: string, namespace = 'vgl') {\r\n  /**\r\n   * 返回 `${namespace}-${block}`\r\n   */\r\n  const b = () => `${namespace}-${block}`\r\n  /**\r\n   * 返回 `${namespace}-${block}__${element}`\r\n   */\r\n  const be = (element: string) => `${b()}__${element}`\r\n  /**\r\n   * 返回 `${namespace}-${block}--${modifier}`\r\n   */\r\n  const bm = (modifier: string | number) => `${b()}--${modifier}`\r\n  /**\r\n   * 返回 `${namespace}-${block}__${element}--${modifier}`\r\n   */\r\n  const bem = (element: string, modifier: string | number) => `${b()}__${element}--${modifier}`\r\n\r\n  return {\r\n    b,\r\n    be,\r\n    bm,\r\n    bem,\r\n  }\r\n}\r\n"],"names":["LAYOUT_KEY","EMITTER_KEY","bottom","layout","max","bottomY","i","len","cloneLayout","newLayout","cloneLayoutItem","layoutItem","collides","l1","l2","compact","verticalCompact","minPositions","compareWith","getStatics","sorted","sortLayoutItemsByRowCol","out","l","compactItem","getFirstCollision","minY","correctBounds","bounds","collidesWith","getLayoutItem","id","getAllCollisions","moveElement","x","y","isUserAction","preventCollision","oldX","oldY","movingUp","collisions","collision","moveElementAwayFromCollision","itemToMove","fakeItem","setTransform","top","left","width","height","translate","setTransformRtl","right","setTopLeft","setTopRight","a","b","validateLayout","contextName","subProps","keyArr","item","j","useNameHelper","block","namespace","element","modifier"],"mappings":"AAIa,MAAAA,IAAa,OAAO,YAAY,GAChCC,IAAc,OAAO,aAAa;AAQxC,SAASC,EAAOC,GAAwB;AAC7C,MAAIC,IAAM,GACNC;AACJ,WAASC,IAAI,GAAGC,IAAMJ,EAAO,QAAQG,IAAIC,GAAKD;AAC5C,IAAAD,IAAUF,EAAOG,CAAC,EAAE,IAAIH,EAAOG,CAAC,EAAE,GAC9BD,IAAUD,MAAWA,IAAAC;AAEpB,SAAAD;AACT;AAEO,SAASI,EAAYL,GAAwB;AAC5C,QAAAM,IAAY,MAAMN,EAAO,MAAM;AACrC,WAASG,IAAI,GAAGC,IAAMJ,EAAO,QAAQG,IAAIC,GAAKD;AAC5C,IAAAG,EAAUH,CAAC,IAAII,EAAgBP,EAAOG,CAAC,CAAC;AAEnC,SAAAG;AACT;AAGO,SAASC,EAAgBC,GAAoC;AAE3D,SAAA,EAAE,GAAGA,EAAW;AACzB;AAOgB,SAAAC,EAASC,GAAgBC,GAAyB;AAKhE,SAJI,EAAAD,MAAOC,KACPD,EAAG,IAAIA,EAAG,KAAKC,EAAG,KAClBD,EAAG,KAAKC,EAAG,IAAIA,EAAG,KAClBD,EAAG,IAAIA,EAAG,KAAKC,EAAG,KAClBD,EAAG,KAAKC,EAAG,IAAIA,EAAG;AAExB;AAUgB,SAAAC,EAAQZ,GAAgBa,GAA2BC,GAA4B;AAEvF,QAAAC,IAAcC,EAAWhB,CAAM,GAE/BiB,IAASC,EAAwBlB,CAAM,GAEvCmB,IAAc,MAAMnB,EAAO,MAAM;AAEvC,WAASG,IAAI,GAAGC,IAAMa,EAAO,QAAQd,IAAIC,GAAKD,KAAK;AAC7C,QAAAiB,IAAIH,EAAOd,CAAC;AAGZ,IAACiB,EAAE,WACLA,IAAIC,EAAYN,GAAaK,GAAGP,GAAiBC,CAAY,GAI7DC,EAAY,KAAKK,CAAC,IAIhBD,EAAAnB,EAAO,UAAU,CAAAG,MAAKA,EAAE,MAAMiB,EAAE,CAAC,CAAC,IAAIA,GAG1CA,EAAE,QAAQ;AAAA,EAAA;AAGL,SAAAD;AACT;AAKO,SAASE,EACdN,GACAK,GACAP,GACAC,GACY;AACZ,MAAID;AAEF,WAAOO,EAAE,IAAI,KAAK,CAACE,EAAkBP,GAAaK,CAAC;AAC/C,MAAAA,EAAA;AAAA,WAEKN,GAAc;AACvB,UAAMS,IAAOT,EAAaM,EAAE,CAAC,EAAE;AAC/B,WAAOA,EAAE,IAAIG,KAAQ,CAACD,EAAkBP,GAAaK,CAAC;AAClD,MAAAA,EAAA;AAAA,EACJ;AAIEX,MAAAA;AACJ,SAAQA,IAAWa,EAAkBP,GAAaK,CAAC;AAC/C,IAAAA,EAAA,IAAIX,EAAS,IAAIA,EAAS;AAEvB,SAAAW;AACT;AAQgB,SAAAI,EAAcxB,GAAgByB,GAAkC;AACxE,QAAAC,IAAeV,EAAWhB,CAAM;AACtC,WAASG,IAAI,GAAGC,IAAMJ,EAAO,QAAQG,IAAIC,GAAKD,KAAK;AAC3C,UAAAiB,IAAIpB,EAAOG,CAAC;AAQlB,QANIiB,EAAE,IAAIA,EAAE,IAAIK,EAAO,SAAQL,EAAA,IAAIK,EAAO,OAAOL,EAAE,IAE/CA,EAAE,IAAI,MACRA,EAAE,IAAI,GACNA,EAAE,IAAIK,EAAO,OAEX,CAACL,EAAE,OAAQ,CAAAM,EAAa,KAAKN,CAAC;AAAA;AAIzB,aAAAE,EAAkBI,GAAcN,CAAC;AACpC,QAAAA,EAAA;AAAA,EAEN;AAEK,SAAApB;AACT;AASgB,SAAA2B,EAAc3B,GAAgB4B,GAA6C;AACzF,WAASzB,IAAI,GAAGC,IAAMJ,EAAO,QAAQG,IAAIC,GAAKD;AAC5C,QAAIH,EAAOG,CAAC,EAAE,MAAMyB,EAAI,QAAO5B,EAAOG,CAAC;AAE3C;AASgB,SAAAmB,EAAkBtB,GAAgBQ,GAAgD;AAChG,WAASL,IAAI,GAAGC,IAAMJ,EAAO,QAAQG,IAAIC,GAAKD;AACxC,QAAAM,EAAST,EAAOG,CAAC,GAAGK,CAAU,EAAG,QAAOR,EAAOG,CAAC;AAExD;AAEgB,SAAA0B,EAAiB7B,GAAgBQ,GAA2C;AAC1F,SAAOR,EAAO,OAAO,CAAAoB,MAAKX,EAASW,GAAGZ,CAAU,CAAC;AACnD;AAOO,SAASQ,EAAWhB,GAAmC;AAC5D,SAAOA,EAAO,OAAO,CAAKoB,MAAAA,EAAE,MAAM;AACpC;AAWgB,SAAAU,EACd9B,GACAQ,GACAuB,GACAC,GACAC,IAAe,IACfC,IAAmB,IACX;AACJ,MAAA1B,EAAW,OAAe,QAAAR;AAE9B,QAAMmC,IAAO3B,EAAW,GAClB4B,IAAO5B,EAAW,GAElB6B,IAAWL,KAAKxB,EAAW,IAAIwB;AAErC,EAAI,OAAOD,KAAM,aAAUvB,EAAW,IAAIuB,IACtC,OAAOC,KAAM,aAAUxB,EAAW,IAAIwB,IAC1CxB,EAAW,QAAQ;AAMf,MAAAS,IAASC,EAAwBlB,CAAM;AACvC,EAAAqC,MAAmBpB,IAAAA,EAAO,QAAQ;AAChC,QAAAqB,IAAaT,EAAiBZ,GAAQT,CAAU;AAElD,MAAA0B,KAAoBI,EAAW;AACjC,WAAA9B,EAAW,IAAI2B,GACf3B,EAAW,IAAI4B,GACf5B,EAAW,QAAQ,IACZR;AAIT,WAASG,IAAI,GAAGC,IAAMkC,EAAW,QAAQnC,IAAIC,GAAKD,KAAK;AAC/C,UAAAoC,IAAYD,EAAWnC,CAAC;AAG9B,IAAIoC,EAAU,SAGV/B,EAAW,IAAI+B,EAAU,KAAK/B,EAAW,IAAI+B,EAAU,IAAIA,EAAU,IAAI,MAGzEA,EAAU,SACZvC,IAASwC,EAA6BxC,GAAQuC,GAAW/B,GAAYyB,CAAY,IAEjFjC,IAASwC,EAA6BxC,GAAQQ,GAAY+B,GAAWN,CAAY;AAAA,EACnF;AAGK,SAAAjC;AACT;AAUO,SAASwC,EACdxC,GACA0B,GACAe,GACAR,GACQ;AAKR,MAAIA,GAAc;AAEhB,UAAMS,IAAuB;AAAA,MAC3B,GAAGD,EAAW;AAAA,MACd,GAAGA,EAAW;AAAA,MACd,GAAGA,EAAW;AAAA,MACd,GAAGA,EAAW;AAAA,IAEhB;AAEA,QADAC,EAAS,IAAI,KAAK,IAAIhB,EAAa,IAAIe,EAAW,GAAG,CAAC,GAClD,CAACnB,EAAkBtB,GAAQ0C,CAAQ;AACrC,aAAOZ,EAAY9B,GAAQyC,GAAY,QAAWC,EAAS,GAAG,EAAgB;AAAA,EAChF;AAKF,SAAOZ,EAAY9B,GAAQyC,GAAY,QAAWA,EAAW,IAAI,GAAG,EAAgB;AACtF;AAYO,SAASE,EAAaC,GAAaC,GAAcC,GAAeC,GAAgB;AAErF,QAAMC,IAAY,iBAAiBH,IAAO,QAAQD,IAAM;AACjD,SAAA;AAAA,IACL,WAAWI;AAAA,IACX,iBAAiBA;AAAA,IACjB,cAAcA;AAAA,IACd,aAAaA;AAAA,IACb,YAAYA;AAAA,IACZ,OAAOF,IAAQ;AAAA,IACf,QAAQC,IAAS;AAAA,IACjB,UAAU;AAAA,EACZ;AACF;AAIO,SAASE,EAAgBL,GAAaM,GAAeJ,GAAeC,GAAgB;AAEzF,QAAMC,IAAY,iBAAiBE,IAAQ,KAAK,QAAQN,IAAM;AACvD,SAAA;AAAA,IACL,WAAWI;AAAA,IACX,iBAAiBA;AAAA,IACjB,cAAcA;AAAA,IACd,aAAaA;AAAA,IACb,YAAYA;AAAA,IACZ,OAAOF,IAAQ;AAAA,IACf,QAAQC,IAAS;AAAA,IACjB,UAAU;AAAA,EACZ;AACF;AAEO,SAASI,EAAWP,GAAaC,GAAcC,GAAeC,GAAgB;AAC5E,SAAA;AAAA,IACL,KAAKH,IAAM;AAAA,IACX,MAAMC,IAAO;AAAA,IACb,OAAOC,IAAQ;AAAA,IACf,QAAQC,IAAS;AAAA,IACjB,UAAU;AAAA,EACZ;AACF;AAIO,SAASK,EAAYR,GAAaM,GAAeJ,GAAeC,GAAgB;AAC9E,SAAA;AAAA,IACL,KAAKH,IAAM;AAAA,IACX,OAAOM,IAAQ;AAAA,IACf,OAAOJ,IAAQ;AAAA,IACf,QAAQC,IAAS;AAAA,IACjB,UAAU;AAAA,EACZ;AACF;AAKO,SAAS7B,EAAwBlB,GAAwB;AAC9D,SAAO,MAAM,KAAKA,CAAM,EAAE,KAAK,SAAUqD,GAAGC,GAAG;AAC7C,WAAID,EAAE,MAAMC,EAAE,KAAKD,EAAE,MAAMC,EAAE,IACpB,IAGLD,EAAE,IAAIC,EAAE,KAAMD,EAAE,MAAMC,EAAE,KAAKD,EAAE,IAAIC,EAAE,IAChC,IAGF;AAAA,EAAA,CACR;AACH;AASgB,SAAAC,EAAevD,GAAgBwD,GAA4B;AACzE,EAAAA,IAAcA,KAAe;AAC7B,QAAMC,IAAW,CAAC,KAAK,KAAK,KAAK,GAAG,GAC9BC,IAAS,CAAC;AACZ,MAAA,CAAC,MAAM,QAAQ1D,CAAM,EAAS,OAAA,IAAI,MAAMwD,IAAc,oBAAoB;AAC9E,WAAS,IAAI,GAAGpD,IAAMJ,EAAO,QAAQ,IAAII,GAAK,KAAK;AAC3C,UAAAuD,IAAO3D,EAAO,CAAC;AACrB,aAAS4D,IAAI,GAAGA,IAAIH,EAAS,QAAQG;AACnC,UAAI,OAAQD,EAAaF,EAASG,CAAC,CAAC,KAAM;AACxC,cAAM,IAAI;AAAA,UACR,oBAAoBJ,IAAc,MAAM,IAAI,OAAOC,EAASG,CAAC,IAAI;AAAA,QACnE;AAIJ,QAAID,EAAK,MAAM,UAAaA,EAAK,MAAM;AACrC,YAAM,IAAI,MAAM,oBAAoBH,IAAc,MAAM,IAAI,qBAAqB;AAGnF,QAAI,OAAOG,EAAK,KAAM,YAAY,OAAOA,EAAK,KAAM;AAClD,YAAM,IAAI,MAAM,oBAAoBH,IAAc,MAAM,IAAI,iCAAiC;AAG/F,QAAIE,EAAO,QAAQC,EAAK,CAAC,KAAK;AAC5B,YAAM,IAAI,MAAM,oBAAoBH,IAAc,MAAM,IAAI,qBAAqB;AAInF,QAFOE,EAAA,KAAKC,EAAK,CAAC,GAEdA,EAAK,WAAW,UAAa,OAAOA,EAAK,UAAW;AACtD,YAAM,IAAI,MAAM,oBAAoBH,IAAc,MAAM,IAAI,6BAA6B;AAAA,EAC3F;AAEJ;AAsGgB,SAAAK,EAAcC,GAAeC,IAAY,OAAO;AAI9D,QAAMT,IAAI,MAAM,GAAGS,CAAS,IAAID,CAAK;AAc9B,SAAA;AAAA,IACL,GAAAR;AAAA,IACA,IAZS,CAACU,MAAoB,GAAGV,GAAG,KAAKU,CAAO;AAAA,IAahD,IATS,CAACC,MAA8B,GAAGX,GAAG,KAAKW,CAAQ;AAAA,IAU3D,KANU,CAACD,GAAiBC,MAA8B,GAAGX,EAAG,CAAA,KAAKU,CAAO,KAAKC,CAAQ;AAAA,EAO3F;AACF;"}
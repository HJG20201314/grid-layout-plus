{"version":3,"file":"responsive.cjs","sources":["../../src/helpers/responsive.ts"],"sourcesContent":["import { cloneLayout, compact, correctBounds } from './common'\r\n\r\nimport type { Breakpoint, Breakpoints, Layout, ResponsiveLayout } from './types'\r\n\r\n/**\r\n * 给定一个宽度，找到满足条件的最高断点（width > breakpoint）。\r\n *\r\n * @param breakpoints 断点对象 (例如 {lg: 1200, md: 960, ...})\r\n * @param width 屏幕宽度。\r\n * @return 小于该宽度的最大断点名称。\r\n */\r\nexport function getBreakpointFromWidth(breakpoints: Breakpoints, width: number): Breakpoint {\r\n  const sorted = sortBreakpoints(breakpoints)\r\n  let matching = sorted[0]\r\n  for (let i = 1, len = sorted.length; i < len; i++) {\r\n    const breakpointName = sorted[i]\r\n    if (width > breakpoints[breakpointName]) matching = breakpointName\r\n  }\r\n  return matching\r\n}\r\n\r\n/**\r\n * 根据断点获取对应的列数。\r\n * @param breakpoint 断点名称。\r\n * @param cols 断点与列数的映射表。\r\n * @return 列数。\r\n */\r\nexport function getColsFromBreakpoint(breakpoint: Breakpoint, cols: Breakpoints): number {\r\n  if (!cols[breakpoint]) {\r\n    throw new Error(\r\n      'ResponsiveGridLayout: `cols` entry for breakpoint ' + breakpoint + ' is missing!',\r\n    )\r\n  }\r\n  return cols[breakpoint]\r\n}\r\n\r\n/**\r\n * 根据已存在的布局与一个新的断点，查找或生成一个新的布局。\r\n *\r\n * 若更高的断点已有布局，则基于其生成；否则基于原始布局复制。\r\n *\r\n * @param orgLayout 原始布局。\r\n * @param layouts 已存在的各断点布局。\r\n * @param breakpoints 所有断点。\r\n * @param breakpoint 新断点。\r\n * @param lastBreakpoint 上一个断点（用于回退）。\r\n * @param cols 新断点的列数。\r\n * @param verticalCompact 是否垂直压缩布局。\r\n * @return 新布局。\r\n */\r\nexport function findOrGenerateResponsiveLayout(\r\n  orgLayout: Layout,\r\n  layouts: ResponsiveLayout,\r\n  breakpoints: Breakpoints,\r\n  breakpoint: Breakpoint,\r\n  lastBreakpoint: Breakpoint,\r\n  cols: number,\r\n  verticalCompact: boolean,\r\n): Layout {\r\n  // debugger\r\n  // 如果已存在该断点布局，直接返回其克隆。\r\n  if (layouts[breakpoint]) return cloneLayout(layouts[breakpoint])\r\n  // 查找或生成下一个布局\r\n  let layout = orgLayout\r\n\r\n  const breakpointsSorted = sortBreakpoints(breakpoints)\r\n  const breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint))\r\n  for (let i = 0, len = breakpointsAbove.length; i < len; i++) {\r\n    const b = breakpointsAbove[i]\r\n    if (layouts[b]) {\r\n      layout = layouts[b]\r\n      break\r\n    }\r\n  }\r\n  // 克隆布局，避免修改原对象\r\n  layout = cloneLayout(layout || []) // clone layout so we don't modify existing items\r\n  return compact(correctBounds(layout, { cols }), verticalCompact)\r\n}\r\n\r\nexport function generateResponsiveLayout(\r\n  layout: Layout,\r\n  breakpoints: Breakpoints,\r\n  breakpoint: Breakpoint,\r\n  lastBreakpoint: Breakpoint,\r\n  cols: number,\r\n  verticalCompact: boolean,\r\n): Layout {\r\n  // 如果已存在对应断点布局则直接返回（本实现中已注释相关逻辑）。\r\n  /* if (layouts[breakpoint]) return cloneLayout(layouts[breakpoint]);\r\n  // 查找或生成下一个布局\r\n  let layout = layouts[lastBreakpoint]; */\r\n  /* const breakpointsSorted = sortBreakpoints(breakpoints);\r\nconst breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\r\nfor (let i = 0, len = breakpointsAbove.length; i < len; i++) {\r\n  const b = breakpointsAbove[i];\r\n  if (layouts[b]) {\r\n    layout = layouts[b];\r\n    break;\r\n  }\r\n} */\r\n  // 克隆布局防止修改原数据\r\n  layout = cloneLayout(layout || []) // clone layout so we don't modify existing items\r\n  return compact(correctBounds(layout, { cols }), verticalCompact)\r\n}\r\n\r\n/**\r\n * 给定断点映射，返回按宽度排序的断点数组，例如 ['xxs','xs','sm',...]。\r\n *\r\n * @param breakpoints 断点名到宽度的键值对。\r\n * @return 排序后的断点数组。\r\n */\r\nexport function sortBreakpoints(breakpoints: Breakpoints): Array<Breakpoint> {\r\n  const keys = Object.keys(breakpoints) as Array<Breakpoint>\r\n  return keys.sort((a, b) => breakpoints[a] - breakpoints[b])\r\n}\r\n"],"names":["getBreakpointFromWidth","breakpoints","width","sorted","sortBreakpoints","matching","i","len","breakpointName","getColsFromBreakpoint","breakpoint","cols","findOrGenerateResponsiveLayout","orgLayout","layouts","lastBreakpoint","verticalCompact","cloneLayout","layout","breakpointsSorted","breakpointsAbove","b","compact","correctBounds","a"],"mappings":"gHAWgB,SAAAA,EAAuBC,EAA0BC,EAA2B,CACpF,MAAAC,EAASC,EAAgBH,CAAW,EACtC,IAAAI,EAAWF,EAAO,CAAC,EACvB,QAASG,EAAI,EAAGC,EAAMJ,EAAO,OAAQG,EAAIC,EAAKD,IAAK,CAC3C,MAAAE,EAAiBL,EAAOG,CAAC,EAC3BJ,EAAQD,EAAYO,CAAc,IAAcH,EAAAG,EAAA,CAE/C,OAAAH,CACT,CAQgB,SAAAI,EAAsBC,EAAwBC,EAA2B,CACnF,GAAA,CAACA,EAAKD,CAAU,EAClB,MAAM,IAAI,MACR,qDAAuDA,EAAa,cACtE,EAEF,OAAOC,EAAKD,CAAU,CACxB,CAgBO,SAASE,EACdC,EACAC,EACAb,EACAS,EACAK,EACAJ,EACAK,EACQ,CAGR,GAAIF,EAAQJ,CAAU,SAAUO,EAAAA,YAAYH,EAAQJ,CAAU,CAAC,EAE/D,IAAIQ,EAASL,EAEP,MAAAM,EAAoBf,EAAgBH,CAAW,EAC/CmB,EAAmBD,EAAkB,MAAMA,EAAkB,QAAQT,CAAU,CAAC,EACtF,QAASJ,EAAI,EAAGC,EAAMa,EAAiB,OAAQd,EAAIC,EAAKD,IAAK,CACrD,MAAAe,EAAID,EAAiBd,CAAC,EACxB,GAAAQ,EAAQO,CAAC,EAAG,CACdH,EAASJ,EAAQO,CAAC,EAClB,KAAA,CACF,CAGO,OAAAH,EAAAD,EAAAA,YAAYC,GAAU,EAAE,EAC1BI,EAAAA,QAAQC,EAAAA,cAAcL,EAAQ,CAAE,KAAAP,CAAK,CAAC,EAAGK,CAAe,CACjE,CAkCO,SAASZ,EAAgBH,EAA6C,CAEpE,OADM,OAAO,KAAKA,CAAW,EACxB,KAAK,CAACuB,EAAGH,IAAMpB,EAAYuB,CAAC,EAAIvB,EAAYoB,CAAC,CAAC,CAC5D"}